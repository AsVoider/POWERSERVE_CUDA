#!/usr/bin/python3

import argparse
import os
from pathlib import Path
from typing import List, Dict, Set
import subprocess
import shutil
import json
from datetime import datetime
import logging

# gloabl config
HYPER_PARAMS_FILENAME_KEY = "hparams_config"
MAIN_MODEL_KEY = "model_main"
DRAFT_MODEL_KEY = "model_draft"
MODEL_CONFIG_FILENAME_KEY = "model_config"
VISION_CONFIG_FILENAME_KEY = "vision_config"
ARTIFACT_CONFIG_FILENAME = "artifact.json"
QNN_WORKSPACE_DIR_NAME = "qnn-workspace"
MODEL_VOCAB_FILENAME = "vocab"
EXECUTABLE_PATH_KEY = "executables"

logging.basicConfig(
    filename=f'smartserving_{datetime.today().strftime("%Y_%m_%d")}.log',
    level=logging.INFO,
    format="[%(asctime)s] - [%(levelname)s] - %(funcName)s - %(message)s",
    datefmt="%Y-%m-%d-%H:%M:%S",
)

root_folder = Path(".").absolute()
logging.info(f"current root: {root_folder}")


default_hparams = {
    "n_predicts": 32,
    "n_threads": 4,
    "prompt_file": "",
    "sampler": {
        "seed": 20241211,
        "temperature": 0.8,
        "top_p": 0.95,
        "top_k": 40,
        "min_keep": 0,
        "penalty_last_n": 64,
        "penalty_repeat": 1,
        "penalty_freq": 0,
        "penalty_present": 0,
        "penalize_nl": False,
        "ignore_eos": False,
    },
}


def exec(cmd_args):
    cmd = " ".join(map(str, cmd_args))
    print(f"> {cmd}")
    p = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, encoding="utf-8")
    p.wait()
    if p.returncode != 0:
        logging.error(p.stderr.read())
        print(p.stderr.read())
    assert p.returncode == 0


def export_hparams(out_path: Path, config: Dict) -> Path:
    params_file = Path("hparams.json")
    with open(out_path / params_file, "w") as fp:
        json.dump(config, fp, indent=4)
    return params_file


def read_json(path: Path) -> Dict:
    config = {}
    with open(path, "r") as fp:
        config = json.load(fp)
    return config


def write_json(path: Path, config: Dict):
    with open(path, "w") as fp:
        json.dump(config, fp, indent=4)


def smart_create(args):
    out_path: Path = args.out_path
    main_model_path: Path = args.main_model
    draft_model_path: Path = args.draft_model
    exe_path: Path = args.exe_path

    if not out_path.exists():
        out_path.mkdir(parents=True, exist_ok=True)
    assert out_path.is_dir(), f"{out_path} is not a directory"

    artifact_config = {}

    artifact_config[HYPER_PARAMS_FILENAME_KEY] = "hparams.json"
    write_json(out_path / artifact_config[HYPER_PARAMS_FILENAME_KEY], default_hparams)

    artifact_config[MAIN_MODEL_KEY] = main_model_path.name
    exec(["cp", "-r", main_model_path, out_path / artifact_config[MAIN_MODEL_KEY]])
    model_file = list(main_model_path.rglob("weights.gguf"))[0]
    tool_path = out_path / "bin/smart-config_generator"
    config_file_name = "model.config"
    exec([
        tool_path,
        "--file-path",
        model_file,
        "--target-path",
        out_path / artifact_config[MAIN_MODEL_KEY] / config_file_name,
    ])
    model_config = {"model_id": "", "model_arch": "", "version": 0, "llm_config": {}, "vision": {}}
    src: Dict = json.load(out_path / artifact_config[MAIN_MODEL_KEY] / config_file_name)
    model_config["model_id"] = args.main_model_id
    model_config["model_arch"] = src["model_arch"]
    model_config["version"] = src["version"]
    src.pop("model_arch")
    src.pop("version")
    model_config["llm_config"] = src
    with open(out_path / artifact_config[MAIN_MODEL_KEY] / config_file_name, "w") as f:
        json.dump(model_config, f, indent=2)

    if draft_model_path:
        artifact_config[DRAFT_MODEL_KEY] = draft_model_path.name
        exec(["cp", "-r", draft_model_path, out_path / artifact_config[DRAFT_MODEL_KEY]])
        model_file = list(main_model_path.rglob("weights.gguf"))[0]
        config_file_name = "model.config"
        exec([
            tool_path,
            "--file-path",
            model_file,
            "--target-path",
            out_path / artifact_config[DRAFT_MODEL_KEY] / config_file_name,
        ])
        src: Dict = json.load(out_path / artifact_config[DRAFT_MODEL_KEY] / config_file_name)
        model_config["model_id"] = args.draft_model_id
        model_config["model_arch"] = src["model_arch"]
        model_config["version"] = src["version"]
        src.pop("model_arch")
        src.pop("version")
        model_config["llm_config"] = src
        with open(out_path / artifact_config[DRAFT_MODEL_KEY] / config_file_name, "w") as f:
            json.dump(model_config, f, indent=2)
    else:
        artifact_config[DRAFT_MODEL_KEY] = ""

    artifact_config[EXECUTABLE_PATH_KEY] = "bin"
    bin_path = out_path / artifact_config[EXECUTABLE_PATH_KEY]
    if not bin_path.exists():
        bin_path.mkdir(parents=True, exist_ok=True)

    if exe_path:
        exec(["cp", "-r", exe_path, bin_path])

    write_json(out_path / ARTIFACT_CONFIG_FILENAME, artifact_config)


def smart_run(args):
    package_path: Path = args.pkg_path
    cmd = []

    assert package_path.is_dir(), f"{package_path} is not a directory"

    artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)

    # assamble executable args
    run_path: Path = package_path / artifact_config[EXECUTABLE_PATH_KEY] / f"smart-run"
    cmd.append(run_path)

    # assamnle model args
    cmd.extend(["--work-folder", package_path.absolute()])

    if args.no_qnn:
        cmd.extend(["--no-qnn"])
    else:
        cmd.insert(0, "export LD_LIBRARY_PATH=/vendor/lib64 && sudo -E ")

    exec(cmd)


def smart_server(args):
    package_path: Path = args.pkg_path
    cmd = []

    assert package_path.is_dir(), f"{package_path} is not a directory"

    artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)

    # assamble executable args
    run_path: Path = package_path / artifact_config[EXECUTABLE_PATH_KEY] / f"smart-server"
    cmd.append(run_path)

    # assamnle model args
    cmd.extend(["--work-folder", package_path.absolute(), "--host", args.host, "--port", args.port])

    if args.no_qnn:
        cmd.extend(["--no-qnn"])
    else:
        cmd.insert(0, "export LD_LIBRARY_PATH=/vendor/lib64 && sudo -E ")

    exec(cmd)


def smart_ppl(args):
    package_path: Path = args.pkg_path
    cmd = []

    assert package_path.is_dir(), f"{package_path} is not a directory"

    artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)

    # assamble executable args
    run_path: Path = package_path / artifact_config[EXECUTABLE_PATH_KEY] / f"smart-perplexity_test"
    cmd.append(run_path)

    cmd.extend(["--work-folder", package_path.absolute(), "--batch-size", args.batch_size])

    if args.no_qnn:
        cmd.extend(["--no-qnn"])
    else:
        cmd.insert(0, "export LD_LIBRARY_PATH=/vendor/lib64 && sudo -E ")

    exec(cmd)


def smart_speculate(args):
    package_path: Path = args.pkg_path
    cmd = []

    assert package_path.is_dir(), f"{package_path} is not a directory"

    artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)

    # assamble executable args
    run_path: Path = package_path / artifact_config[EXECUTABLE_PATH_KEY] / f"smart-speculative"
    cmd.append(run_path)

    # assamnle model args
    cmd.extend(["--work-folder", package_path.absolute()])

    if not args.no_qnn:
        cmd.insert(0, "export LD_LIBRARY_PATH=/vendor/lib64 && sudo -E ")
    else:
        print("cpu is not supported now")
        exit(0)

    exec(cmd)


class HyperParametersManager:

    @staticmethod
    def check_params_file(file: Path) -> bool:
        if file.exists():
            return True
        print(f"Not found params file: {file}, please create one")
        return False

    @staticmethod
    def get_params(args):
        package_path: Path = args.pkg_path
        assert package_path.is_dir(), f"{package_path} is not a directory"
        artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)
        hyper_params_path = package_path / artifact_config[HYPER_PARAMS_FILENAME_KEY]

        print_dict = lambda parent_key, d: [
            (print(f"{parent_key}{k}: {v}") if type(v) is not dict else print_dict(f"{parent_key}{k}.", v))
            for k, v in d.items()
        ]

        if HyperParametersManager.check_params_file(hyper_params_path):
            hyper_params = read_json(hyper_params_path)
            print_dict("", hyper_params)

    @staticmethod
    def set_params(args):
        package_path: Path = args.pkg_path
        entries: List[str] = args.entries
        assert package_path.is_dir(), f"{package_path} is not a directory"
        artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)
        hyper_params_path = package_path / artifact_config[HYPER_PARAMS_FILENAME_KEY]

        def set_entry(d: Dict, k: List, v):
            if len(k) < 0:
                return

            first_k = k.pop(0)
            if len(k) == 0:
                v_type = type(v)
                if first_k in d:
                    v_type = type(d[first_k])
                    print(f"{first_k}: {d[first_k]} -> {v}")
                else:
                    print(f"Unrecongized parameter: {first_k}")
                    return

                if v_type in [list, set, tuple, dict]:
                    d[first_k] = eval(v)
                else:
                    d[first_k] = v_type(v)
            else:
                if first_k not in d:
                    d[first_k] = {}
                set_entry(d[first_k], k, v)

        def parse_entry(params: Dict, entry: str):
            try:
                k, v = entry.strip().split("=")
                k = k.split(".")
                set_entry(params, k, v)
            except:
                raise SyntaxError(f"parse error: {entry}")

        if HyperParametersManager.check_params_file(hyper_params_path):
            hyper_params = read_json(hyper_params_path)
            for entry in entries:
                parse_entry(hyper_params, entry)
            write_json(hyper_params_path, hyper_params)

    @staticmethod
    def store_params(args):
        package_path: Path = args.pkg_path
        file: Path = args.file

        assert package_path.is_dir(), f"{package_path} is not a directory"
        artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)
        hyper_params_path = package_path / artifact_config[HYPER_PARAMS_FILENAME_KEY]

        write_json(file, read_json(hyper_params_path))

    @staticmethod
    def load_params(args):
        package_path: Path = args.pkg_path
        file: Path = args.file

        assert package_path.is_dir(), f"{package_path} is not a directory"
        artifact_config = read_json(package_path / ARTIFACT_CONFIG_FILENAME)
        hyper_params_path = package_path / artifact_config[HYPER_PARAMS_FILENAME_KEY]

        assert file.exists(), f"Not found {file}"
        write_json(hyper_params_path, read_json(file))


def command():
    parser = argparse.ArgumentParser(prog="SmartServing", description="SmartServing CommandLine Tool")
    subparser = parser.add_subparsers()
    # ============== Create ==============
    create_parser = subparser.add_parser("create")
    create_parser.add_argument("-m", "--main-model", type=Path, required=True, help="Main model path")
    create_parser.add_argument("-d", "--draft-model", type=Path, help="Draft model path", default=None)
    create_parser.add_argument("-o", "--out-path", type=Path, default=Path("./proj/"), help="Output path")
    create_parser.add_argument("--main-model-id", type=str, required=True, help="Main model ID")
    create_parser.add_argument("--draft-model-id", type=str, required=True, help="Draft model ID")
    create_parser.add_argument("--exe-path", type=Path, default=None)
    create_parser.set_defaults(func=smart_create)
    # ============== Run ==============
    run_parser = subparser.add_parser("run")
    run_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    run_parser.add_argument("--no-qnn", action="store_true")
    run_parser.set_defaults(func=smart_run)
    # ============== Server ==============
    server_parser = subparser.add_parser("server")
    server_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    server_parser.add_argument("--host", type=str, default="0.0.0.0", help="Server host")
    server_parser.add_argument("-p", "--port", type=int, default=18080, help="Server port")
    server_parser.add_argument("--no-qnn", action="store_true")
    server_parser.set_defaults(func=smart_server)
    # ============== PPL ==============
    ppl_parser = subparser.add_parser("ppl")
    ppl_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    ppl_parser.add_argument("-b", "--batch-size", type=int, default=32)
    ppl_parser.add_argument("--no-qnn", action="store_true")
    ppl_parser.set_defaults(func=smart_ppl)
    # ============== Speculate ==============
    speculate_parser = subparser.add_parser("speculate")
    speculate_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    speculate_parser.add_argument("--no-qnn", action="store_true")
    speculate_parser.set_defaults(func=smart_speculate)

    # ============== HyperParameters ==============
    parameters_subparser = subparser.add_parser("hparams").add_subparsers()
    # ============== GetHyperParameters ==============
    get_hparams_parser = parameters_subparser.add_parser("get")
    get_hparams_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    get_hparams_parser.set_defaults(func=HyperParametersManager.get_params)
    # ============== SetHyperParameters ==============
    set_hparams_parser = parameters_subparser.add_parser("set")
    set_hparams_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    set_hparams_parser.add_argument("-e", "--entries", type=str, required=True, nargs="+")
    set_hparams_parser.set_defaults(func=HyperParametersManager.set_params)
    # =============== StoreHyperParameters ==============
    store_hparams_parser = parameters_subparser.add_parser("store")
    store_hparams_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    store_hparams_parser.add_argument("-f", "--file", type=Path, required=True)
    store_hparams_parser.set_defaults(func=HyperParametersManager.store_params)
    # =============== LoadHyperParameters ==============
    load_hparams_parser = parameters_subparser.add_parser("load")
    load_hparams_parser.add_argument("-d", "--pkg-path", type=Path, required=True, help="Package Path")
    load_hparams_parser.add_argument("-f", "--file", type=Path, required=True)
    load_hparams_parser.set_defaults(func=HyperParametersManager.load_params)

    args = parser.parse_args()

    args.func(args)


command()
